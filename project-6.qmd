---
title: "Programming Project 6"
---

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
library(readxl)
assignments <- read_excel("assessment_schedule.xlsx") %>% 
  mutate(formatted_date = format(due_date, "%A, %B %d, %Y"))
```

Programming Projects are to be submitted to [gradescope](https://www.gradescope.com/courses/676322).

**Due date: `r assignments %>% filter(assessment == "Programming Project 6") %>% pull(formatted_date)` at 7pm**

This programming project is an adaptation of Ben Dicken's Encrypter / Decrypter Programming Assignment.

# Encrypter / Decrypter

This assignment exercises file reading and writing, random, and use of lists. You are going to write two separate programs which work together to encrypt ("mix-up”" and decrypt ("re-assemble") `.txt` files, `.py` files, and other text-based files.

Perhaps you've heard of the concept of "Encryption" in passing. In this assignment, we are going to be writing programs that are capable of encrypting and decrypting text files. The Wikipedia definition of Encryption goes like so:

> In cryptography, encryption is the process of encoding a message or information in such a way that only authorized parties can access it. Encryption does not itself prevent interference, but denies the intelligible content to a would-be interceptor. In an encryption scheme, the intended information or message, referred to as plaintext, is encrypted using an encryption algorithm, generating ciphertext that can only be read if decrypted. For technical reasons, an encryption scheme usually uses a pseudo-random encryption key generated by an algorithm. It is in principle possible to decrypt the message without possessing the key, but, for a well-designed encryption scheme, considerable computational resources and skills are required. An authorized recipient can easily decrypt the message with the key provided by the originator to recipients but not to unauthorized users.

We are going to implement two programs (one to encrypt a text file, and one to decrypt).

## Encrypter

The first program you will write shall be named `encrypter.py`. The job of this program will be to encrypt ("mix" or "shuffle") the lines of a text file, but do it in such a way that it can be un-done later with a separate program (which you will also write).

When run, your program will accept as argument a file name to encrypt. This program will then run its encrypting (mixing) algorithm on the text file named `file_name`. It will save the encrypted version of the text file to a file named `encrypted.txt`.

Your program will encrypt an input file by re-arranging the lines of the input file, based on indexes retrieved from calling `randint`. For example, to encrypt a file named `sample.txt` that looks like this:

<pre>
|'''''|
| 0 0 |
|  ^  |
|  -  |
 ----- 
   # 
#######
  ###
 #   #
 %   %
</pre> 
 

After running, `encrypted.txt` will have the following contents:

<pre>
| 0 0 |
 %   %
#######
   # 
|'''''|
|  ^  |
  ###
|  -  |
 #   #
 ----- 
</pre>

All of the same lines from the original file exist in this file, but the order is not the same.

Whenever `encrypter.py` runs, it will also write an index (key) file. This file will contain the corresponding indexes of each line in the encrypted file. Given the example above, `index.txt` would look like this:

<pre>
2
10
7
6
1
3
8
4
9
5
</pre>

The number on each line of the file is the line number that each shuffled line was on in the original program. For example: 2 is on the first line. This means that the first line of the encrypted file was originally on line 2 of the input file. 10 is on the second line. This means that the second line of the encrypted file was originally on line 10 of the input file.

Without the `index.txt` file, another program or a human would not know how to decrypt the `encrypted.txt` file. If a human or program has both the `encrypted` file and the `index` file, it can be decrypted systematically. Thus the index file works like a secret "key" for the program. Whoever has access to both the index file and the encrypted text can decrypt the encrypted text.

## Decrypter

After writing `encrypter.py`, you are to write a related program named `decrypter.py` which will take the name of a text file and index (key) file, and then it will decrypt the text. The program will read in these two files, and using the information stored within them, it will put the contents back in the original order. The decrypted file should be saved to a file named `decrypted.txt`

You should use lists and the indexes from the index file to help with getting the lines back in the correct order.

There will be multiple examples of running this program at the end of this specification. Make sure to test your code carefully using the tool!

# The encrypting algorithm

The steps of the algorithm are outlined below and you must implement these steps in python. Note that the below steps are just the steps for how to determine which lines to put where in the encrypted file. You also need to handle all of the file reading, writing, etc.

* Import the random python library
* Initialize the random library with a seed value of `42`. Just use the line of code `random.seed(42)`.
* However many lines there are in the input text file, repeat the following steps (line_count * 5) times.
  * Chose two random integers starting from zero and going up to the number of lines in the file minus 1
  * Swap the content of the lines at these two indexes
  
By choosing the seed `42`, you should get the same results if you follow the steps carefully.

##  Test cases

* [sample.txt](data/sample.txt)
* [poem.txt](data/poem.txt)
* [few-steps.txt](data/few-steps.txt)
* [many-steps.txt](data/many-steps.txt)


Call for `encrypter.py`: 

```{python}
#| eval: false
#| echo: true
if __name__ == "__main__":
    encrypt_file("sample.txt")
```

Call for `decrypter.py`:

```{python}
#| eval: false
#| echo: true
if __name__ == "__main__":
    decrypt_file()
```

